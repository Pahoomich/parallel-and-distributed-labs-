#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <wait.h>
#include "ipc.h"

int main(int argc, char *argv[]) {
    //крч я отошел от getopt, optarg(возможно вернемся!!!), они по сути являются такими прям стандартными, для получение параметров через флаги
//    и тот код который есть прям по патерну сделан, я делаю так чтобы показаться дурачкем и убрать коллизию по коду)
//пример нормального использования https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_25.html

//----------парсинг аргументов----------
    int treadCountArg = 1;
    if (argc > 1) {
        for (int i = 1; i < argc; i++) {//i=1 -> пропускаем название программы
            if (!strcmp(argv[i], "-p")) {
                treadCountArg = atoi(argv[i + 1]) + 1;//N = X + 1
                break;
            }
        }
    }

//----------создание пайпов----------
//количество пайпов в полносвязной сети равно N*(N-1)
    int fds[2];
    pipe(fds);

//----------создание процесов----------
    pid_t pid;
    int processPID;
    local_id proccesNumber = 0;// номер процесса, у каждого будет свое значение, реализуется через копию
    for (local_id i = 0; i < treadCountArg; i++) {
        switch (pid = fork()) { //создание дочернего процесса
            case -1:
                perror("fork"); /* произошла ошибка */
                exit(1); /*выход из родительского процесса*/
            case 0:
//----------все что делает ребенок----------
                proccesNumber = i;
                processPID = (int) getpid();
                printf("My PID = %d, my number: %d\n", processPID, proccesNumber);
//----------1. процедура синхронизации со всеми остальными процессами в распределенной системе;----------
//----------2. «полезная» работа дочернего процесса;----------
//----------3. процедура синхронизации процессов перед их завершением.----------
                exit(0);//завершение процесса
            default:
//----------все что делает родитель----------
                proccesNumber = PARENT_ID;//Причем родительскому процессу присваивается идентификатор PARENT_ID, равный 0
                wait(NULL);//тип ожидает когда child процесс завершится
        }
    }
    return 0;
}

